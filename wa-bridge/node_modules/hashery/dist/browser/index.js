var w=Object.defineProperty;var P=(u,e,t)=>e in u?w(u,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):u[e]=t;var h=(u,e,t)=>P(u,typeof e!="symbol"?e+"":e,t);import{Hookified as O}from"hookified";var y=class{constructor(e){h(this,"_enabled",!0);h(this,"_maxSize",4e3);h(this,"_store",new Map);h(this,"_keys",[]);e?.enabled!==void 0&&(this._enabled=e.enabled),e?.maxSize!==void 0&&(this._maxSize=e.maxSize)}get enabled(){return this._enabled}set enabled(e){this._enabled=e}get maxSize(){return this._maxSize}set maxSize(e){this._maxSize=e}get store(){return this._store}get size(){return this._store.size}get(e){return this._store.get(e)}set(e,t){if(this._enabled){if(this._store.has(e)){this._store.set(e,t);return}if(this._store.size>=this._maxSize){let i=this._keys.shift();i&&this._store.delete(i)}this._keys.push(e),this._store.set(e,t)}}has(e){return this._store.has(e)}clear(){this._store.clear(),this._keys=[]}};var b=class{get name(){return"crc32"}toHashSync(e){let t;if(e instanceof Uint8Array)t=e;else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof DataView)t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let o=e;t=new Uint8Array(o.buffer,o.byteOffset,o.byteLength)}let i=3988292384,r=4294967295;for(let o=0;o<t.length;o++){r=r^t[o];for(let n=0;n<8;n++)r=r>>>1^i&-(r&1)}return r=(r^4294967295)>>>0,r.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var p=class{constructor(e){h(this,"_algorithm","SHA-256");e?.algorithm&&(this._algorithm=e?.algorithm)}get name(){return this._algorithm}async toHash(e){let t=await crypto.subtle.digest(this._algorithm,e);return Array.from(new Uint8Array(t)).map(s=>s.toString(16).padStart(2,"0")).join("")}};var H=class{get name(){return"djb2"}toHashSync(e){let t;if(e instanceof Uint8Array)t=e;else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof DataView)t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let s=e;t=new Uint8Array(s.buffer,s.byteOffset,s.byteLength)}let i=5381;for(let s=0;s<t.length;s++)i=(i<<5)+i+t[s],i=i>>>0;return i.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var _=class{get name(){return"fnv1"}toHashSync(e){let t;if(e instanceof Uint8Array)t=e;else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof DataView)t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let n=e;t=new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}let i=2166136261,r=16777619,s=i;for(let n=0;n<t.length;n++)s=s*r,s=s^t[n],s=s>>>0;return s.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var v=class{constructor(e=0){h(this,"_seed");this._seed=e>>>0}get name(){return"murmur"}get seed(){return this._seed}toHashSync(e){let t;if(e instanceof Uint8Array)t=e;else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof DataView)t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let c=e;t=new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}let i=3432918353,r=461845907,s=t.length,o=Math.floor(s/4),n=this._seed;for(let c=0;c<o;c++){let g=c*4,l=t[g]&255|(t[g+1]&255)<<8|(t[g+2]&255)<<16|(t[g+3]&255)<<24;l=this._imul(l,i),l=this._rotl32(l,15),l=this._imul(l,r),n^=l,n=this._rotl32(n,13),n=this._imul(n,5)+3864292196}let m=o*4,a=0;switch(s&3){case 3:a^=(t[m+2]&255)<<16;case 2:a^=(t[m+1]&255)<<8;case 1:a^=t[m]&255,a=this._imul(a,i),a=this._rotl32(a,15),a=this._imul(a,r),n^=a}return n^=s,n^=n>>>16,n=this._imul(n,2246822507),n^=n>>>13,n=this._imul(n,3266489909),n^=n>>>16,n=n>>>0,n.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}_imul(e,t){if(Math.imul)return Math.imul(e,t);let i=e>>>16&65535;let r=e&65535;let s=t>>>16&65535;let o=t&65535;return r*o+(i*o+r*s<<16>>>0)|0}_rotl32(e,t){return e<<t|e>>>32-t}};var x=class{constructor(e){h(this,"_providers",new Map);h(this,"_getFuzzy",!0);e?.providers&&this.loadProviders(e?.providers),e?.getFuzzy!==void 0&&(this._getFuzzy=!!e?.getFuzzy)}loadProviders(e){for(let t of e)this._providers.set(t.name,t)}get providers(){return this._providers}set providers(e){this._providers=e}get names(){return Array.from(this._providers.keys())}get(e,t){let i=t?.fuzzy??this._getFuzzy;e=e.trim();let r=this._providers.get(e);return r===void 0&&i===!0&&(e=e.toLowerCase(),r=this._providers.get(e)),r===void 0&&i===!0&&(e=e.replaceAll("-",""),r=this._providers.get(e)),r}add(e){this._providers.set(e.name,e)}remove(e){return this._providers.delete(e)}};var A=class extends O{constructor(t){super(t);h(this,"_parse",JSON.parse);h(this,"_stringify",JSON.stringify);h(this,"_providers",new x);h(this,"_defaultAlgorithm","SHA-256");h(this,"_defaultAlgorithmSync","djb2");h(this,"_cache");t?.parse&&(this._parse=t.parse),t?.stringify&&(this._stringify=t.stringify),t?.defaultAlgorithm&&(this._defaultAlgorithm=t.defaultAlgorithm),t?.defaultAlgorithmSync&&(this._defaultAlgorithmSync=t.defaultAlgorithmSync),this._cache=new y(t?.cache),this.loadProviders(t?.providers,{includeBase:t?.includeBase??!0})}get parse(){return this._parse}set parse(t){this._parse=t}get stringify(){return this._stringify}set stringify(t){this._stringify=t}get providers(){return this._providers}set providers(t){this._providers=t}get names(){return this._providers.names}get defaultAlgorithm(){return this._defaultAlgorithm}set defaultAlgorithm(t){this._defaultAlgorithm=t}get defaultAlgorithmSync(){return this._defaultAlgorithmSync}set defaultAlgorithmSync(t){this._defaultAlgorithmSync=t}get cache(){return this._cache}async toHash(t,i){let r={data:t,algorithm:i?.algorithm??this._defaultAlgorithm,maxLength:i?.maxLength};await this.beforeHook("toHash",r);let s=this._stringify(r.data),o=`${r.algorithm}:${s}`;if(this._cache.enabled){let g=this._cache.get(o);if(g!==void 0){let l=g;i?.maxLength&&l.length>i.maxLength&&(l=l.substring(0,i.maxLength));let d={hash:l,data:r.data,algorithm:r.algorithm};return await this.afterHook("toHash",d),d.hash}}let m=new TextEncoder().encode(s),a=this._providers.get(r.algorithm);a||(this.emit("warn",`Invalid algorithm '${r.algorithm}' not found. Falling back to default algorithm '${this._defaultAlgorithm}'.`),a=new p({algorithm:this._defaultAlgorithm}));let f=await a.toHash(m);this._cache.enabled&&this._cache.set(o,f),i?.maxLength&&f.length>i?.maxLength&&(f=f.substring(0,i.maxLength));let c={hash:f,data:r.data,algorithm:r.algorithm};return await this.afterHook("toHash",c),c.hash}async toNumber(t,i={}){let{min:r=0,max:s=100,algorithm:o=this._defaultAlgorithm,hashLength:n=16}=i;if(r>s)throw new Error("min cannot be greater than max");let m=await this.toHash(t,{algorithm:o,maxLength:n}),a=Number.parseInt(m,16),f=s-r+1;return r+a%f}toHashSync(t,i){let r={data:t,algorithm:i?.algorithm??this._defaultAlgorithmSync,maxLength:i?.maxLength};this.hookSync("before:toHashSync",r);let s=r.algorithm,o=this._stringify(r.data),n=`${s}:${o}`;if(this._cache.enabled){let l=this._cache.get(n);if(l!==void 0){let d=l;i?.maxLength&&d.length>i.maxLength&&(d=d.substring(0,i.maxLength));let S={hash:d,data:r.data,algorithm:s};return this.hookSync("after:toHashSync",S),S.hash}}let a=new TextEncoder().encode(o),f=this._providers.get(s);if(!f&&(this.emit("warn",`Invalid algorithm '${s}' not found. Falling back to default algorithm '${this._defaultAlgorithmSync}'.`),f=this._providers.get(this._defaultAlgorithmSync),!f))throw new Error(`Hash provider '${this._defaultAlgorithmSync}' (default) not found`);if(!f.toHashSync)throw new Error(`Hash provider '${s}' does not support synchronous hashing. Use toHash() instead or choose a different algorithm (djb2, fnv1, murmur, crc32).`);let c=f.toHashSync(a);this._cache.enabled&&this._cache.set(n,c),i?.maxLength&&c.length>i?.maxLength&&(c=c.substring(0,i.maxLength));let g={hash:c,data:r.data,algorithm:r.algorithm};return this.hookSync("after:toHashSync",g),g.hash}toNumberSync(t,i={}){let{min:r=0,max:s=100,algorithm:o=this._defaultAlgorithmSync,hashLength:n=16}=i;if(r>s)throw new Error("min cannot be greater than max");let m=this.toHashSync(t,{algorithm:o,maxLength:n}),a=Number.parseInt(m,16),f=s-r+1;return r+a%f}loadProviders(t,i={includeBase:!0}){if(t)for(let r of t)this._providers.add(r);i.includeBase&&(this.providers.add(new p({algorithm:"SHA-256"})),this.providers.add(new p({algorithm:"SHA-384"})),this.providers.add(new p({algorithm:"SHA-512"})),this.providers.add(new b),this.providers.add(new H),this.providers.add(new _),this.providers.add(new v))}};export{b as CRC,y as Cache,H as DJB2,_ as FNV1,x as HashProviders,A as Hashery,v as Murmur,p as WebCrypto};
/* v8 ignore next -- @preserve */
//# sourceMappingURL=index.js.map